[
  
  {
    "title": "Swap Nodes in Pairs",
    "url": "/posts/swap-nodes-in-pairs/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-26 00:00:00 +0900",
    





    
    "snippet": "24. Swap Nodes in Pairs문제 설명연결 리스트가 주어질 때, 모든 두 개의 인접 노드를 스왑하고, 스왑한 노드들의 head를 리턴하라.이 문제는 리스트 노드의 values를 바꾸지 않고 해결해야 한다(node 자체를 바꿔야 한다.).해결 방법재귀를 이용해 해결한다.  재귀의 종료 조건은 연결리스트의 끝까지 도달 했을 때이다.  head...",
    "content": "24. Swap Nodes in Pairs문제 설명연결 리스트가 주어질 때, 모든 두 개의 인접 노드를 스왑하고, 스왑한 노드들의 head를 리턴하라.이 문제는 리스트 노드의 values를 바꾸지 않고 해결해야 한다(node 자체를 바꿔야 한다.).해결 방법재귀를 이용해 해결한다.  재귀의 종료 조건은 연결리스트의 끝까지 도달 했을 때이다.  head.next를 변수 p에저장한다.  head.next의 값을 recursive return 값으로 변경한다.  p.next를 head로 변경한다.풀이 코드function swapPairs(head: ListNode | null): ListNode | null {  if (!head || !head.next) return head;  const p = head.next;  head.next = swapPairs(p.next);  p.next = head;  return p;}테스트 코드describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const input = convertArrayToList([1, 2, 3, 4]);    const output = swapPairs(input);    const expected = convertArrayToList([2, 1, 4, 3]);    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const input = null;    const output = swapPairs(input);    const expected = null;    expect(output).toEqual(expected);  });  test('example test 3', () =&gt; {    const input = convertArrayToList([1]);    const output = swapPairs(input);    const expected = convertArrayToList([1]);    expect(output).toEqual(expected);  });});구현 후실제 동작하는 과정과 사람이 보기 편한 이미지는 좀 다르다.그렇기 때문에 연결 리스트에 재귀를 더하면 이해하기 많이 힘들다."
  },
  
  {
    "title": "Add Two Numbers",
    "url": "/posts/add-two-numbers/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-25 00:00:00 +0900",
    





    
    "snippet": "2. Add Two Numbers문제 설명자연수로 나타내고 비어있지 않은 두 개의 연결 리스트가 주어진다. 숫자는 역순으로 저장되어 있고, 각각의 노드에는 한 자리 숫자가 들어있다.두 개의 숫자를 더한 연결 리스트를 반환하라.두 숫자에는 필요한 0을 제외하고, 선행하는 0이 포함되어 있지 않다고 가정한다(가장 앞에 0은 없다).해결 방법역순으로 연결되...",
    "content": "2. Add Two Numbers문제 설명자연수로 나타내고 비어있지 않은 두 개의 연결 리스트가 주어진다. 숫자는 역순으로 저장되어 있고, 각각의 노드에는 한 자리 숫자가 들어있다.두 개의 숫자를 더한 연결 리스트를 반환하라.두 숫자에는 필요한 0을 제외하고, 선행하는 0이 포함되어 있지 않다고 가정한다(가장 앞에 0은 없다).해결 방법역순으로 연결되어 있기 때문에 자연스럽게 우리가 손으로 계산하는 것처럼 하면 된다.  올림 값을 더한다.  l1이 있으면 더한다.  l2가 있으면 더한다.  새로운 리스트를 만들어 더한 값 % 10을 연결한다.  더한 값 / 10의 몫을 올림 값에 저장한다.  끝까지 반복한다.풀이 코드function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {  const head = new ListNode(-1);  let cur = head;  let up = 0;  while (l1 || l2 || up) {    let sum = up;    if (l1) {      sum += l1.val;      l1 = l1.next;    }    if (l2) {      sum += l2.val;      l2 = l2.next;    }    cur.next = new ListNode(sum % 10);    up = Math.floor(sum / 10);    cur = cur.next;  }  return head.next;}테스트 코드import { describe, expect, test } from '@jest/globals';import { addTwoNumbers } from '.';import { convertArrayToList } from '../utils';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const l1 = convertArrayToList([2, 4, 3]);    const l2 = convertArrayToList([5, 6, 4]);    const output = addTwoNumbers(l1, l2);    const expected = convertArrayToList([7, 0, 8]);    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const l1 = convertArrayToList([0]);    const l2 = convertArrayToList([0]);    const output = addTwoNumbers(l1, l2);    const expected = convertArrayToList([0]);    expect(output).toEqual(expected);  });  test('example test 3', () =&gt; {    const l1 = convertArrayToList([9, 9, 9, 9, 9, 9, 9]);    const l2 = convertArrayToList([9, 9, 9, 9]);    const output = addTwoNumbers(l1, l2);    const expected = convertArrayToList([8, 9, 9, 9, 0, 0, 0, 1]);    expect(output).toEqual(expected);  });});"
  },
  
  {
    "title": "Reverse Linked List",
    "url": "/posts/reverse-linked-list/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-24 00:00:00 +0900",
    





    
    "snippet": "206. Reverse Linked List문제 설명단일 연결 리스트의 head가 주어질 때, 리스트를 뒤집고, 뒤집어진 리스트를 리턴하라.해결 방법재귀를 이용하여 리스트를 뒤집는다.  재귀의 종료 조건 받은 node인자가 null일 때 종료한다(리스트를 끝까지 순회 했을 때).  현재 리스트의 다음 노드를 저장하고, 이전 노드를 다음 노드로 연결한다...",
    "content": "206. Reverse Linked List문제 설명단일 연결 리스트의 head가 주어질 때, 리스트를 뒤집고, 뒤집어진 리스트를 리턴하라.해결 방법재귀를 이용하여 리스트를 뒤집는다.  재귀의 종료 조건 받은 node인자가 null일 때 종료한다(리스트를 끝까지 순회 했을 때).  현재 리스트의 다음 노드를 저장하고, 이전 노드를 다음 노드로 연결한다.  재귀 탐색이 종료 될 때까지 반복한다.풀이 코드import { ListNode } from '../utils';export function reverseList(head: ListNode | null): ListNode | null {  if (!head) return head;  const reverse = (node: ListNode, prev: ListNode | null = null): ListNode =&gt; {    if (!node) return prev;    const next = node.next;    node.next = prev;    return reverse(next, node);  };  return reverse(head);}테스트 코드import { describe, expect, test } from '@jest/globals';import { reverseList } from '.';import { convertArrayToList } from '../utils';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const input = convertArrayToList([1, 2, 3, 4, 5]);    const output = reverseList(input);    const expected = convertArrayToList([5, 4, 3, 2, 1]);    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const input = convertArrayToList([1, 2]);    const output = reverseList(input);    const expected = convertArrayToList([2, 1]);    expect(output).toEqual(expected);  });  test('example test 3', () =&gt; {    const input = convertArrayToList([]);    const output = reverseList(input);    const expected = convertArrayToList([]);    expect(output).toEqual(expected);  });});구현 후해당 문제에서 재귀를 이미지로 만들 때 next 포인터를 넣을 지 말지 고민했다.next 포인터를 넣지 않으면 흐름 상 node.next와의 연결이 끊기기 때문에 리스트를 탐색할 수 없다.next를 넣지 않아도 동작을 이해하는데 크게 문제가 없었으므로 이미지로 만들 때는 next포인터를 제외하고 만들었다."
  },
  
  {
    "title": "Merge Two Sorted Lists",
    "url": "/posts/merge-two-sorted-lists/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-23 00:00:00 +0900",
    





    
    "snippet": "21. Merge Two Sorted Lists문제 설명정렬 된 두 개의 연결 리스트 list1과 list2의 head가 주어진다.두 리스트를 하나로 병합하라. 이 리스트는 두 리스트의 노드를 이어 붙여서 만들어야 한다.병합된 연결 리스트의 head를 반환하라.해결 방법재귀를 활용하여, 두 리스트를 병합한다.물론 반복문을 통해서 똑같이 해결할 수 있지...",
    "content": "21. Merge Two Sorted Lists문제 설명정렬 된 두 개의 연결 리스트 list1과 list2의 head가 주어진다.두 리스트를 하나로 병합하라. 이 리스트는 두 리스트의 노드를 이어 붙여서 만들어야 한다.병합된 연결 리스트의 head를 반환하라.해결 방법재귀를 활용하여, 두 리스트를 병합한다.물론 반복문을 통해서 똑같이 해결할 수 있지만 재귀에 비해 반복문은 코드가 더 길어지는 특성이 있다.하지만 재귀는 반복문에 비해 코드의 흐름을 읽기가 쉽지 않고, 대부분의 상황에서 반복문보다 메모리를 더 많이 사용하므로 상황에 따라 적절히 사용하는 것이 중요하다.  재귀의 종료 조건은 list1 또는 list2가 없을 때 종료된다.  list1 &lt; list2일 때 list1을 한 칸 뒤로 옮기고 재귀 호출을 진행한다.  list1 &gt; list2일 때 list2를 한 칸 뒤로 옮기고 재귀 호출을 진행한다.재귀는 다음과 같은 방식으로 연결된다.풀이 코드// Definition for singly-linked list.export class ListNode {  val: number;  next: ListNode | null;  constructor(val?: number, next?: ListNode | null) {    this.val = val === undefined ? 0 : val;    this.next = next === undefined ? null : next;  }}export function mergeTwoLists(  list1: ListNode | null,  list2: ListNode | null): ListNode | null {  if (!list1) return list2;  if (!list2) return list1;  if (list1.val &lt; list2.val) {    list1.next = mergeTwoLists(list1.next, list2);    return list1;  }  list2.next = mergeTwoLists(list1, list2.next);  return list2;}테스트 코드import { describe, expect, test } from '@jest/globals';import { mergeTwoLists, ListNode } from '.';const convertArrayToList = (array: number[]): ListNode | null =&gt; {  if (!array) return null;  const head = new ListNode(-1);  let prev = head;  for (let i = 0; i &lt; array.length; i++) {    prev.next = new ListNode(array[i]);    prev = prev.next;  }  return head.next;};describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const list1 = convertArrayToList([1, 2, 4]);    const list2 = convertArrayToList([1, 3, 4]);    const output = mergeTwoLists(list1, list2);    const expected = convertArrayToList([1, 1, 2, 3, 4, 4]);    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const list1 = null;    const list2 = null;    const output = mergeTwoLists(list1, list2);    const expected = null;    expect(output).toEqual(expected);  });  test('example test 3', () =&gt; {    const list1 = null;    const list2 = convertArrayToList([0]);    const output = mergeTwoLists(list1, list2);    const expected = new ListNode(0);    expect(output).toEqual(expected);  });});구현 후재귀를 막상 GIF로 만드려니 너무 손이 많이간다. 재귀를 그림으로 도식화 할 때는 파이썬 튜터를 한 번 활용해보는 것도 나쁘지 않겠다."
  },
  
  {
    "title": "Palindrome Linked List",
    "url": "/posts/pailndrome-linked-list/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-22 00:00:00 +0900",
    





    
    "snippet": "234. Palindrome Linked List문제 설명단일 연결리스트의 head가 주어질 때, 팰린드롬이면 true 아니면 false를 리턴하라.해결 방법런너 기법을 활용하여 절반의 리스트를 뒤집은 뒤, 팰린드롬을 비교한다.런너 기법은 리스트의 이동하는 두 개 이상의 포인터가 있을 때 이 포인터들의 이동 길이를 다르게 하는 기법이다.런너 기법을 사...",
    "content": "234. Palindrome Linked List문제 설명단일 연결리스트의 head가 주어질 때, 팰린드롬이면 true 아니면 false를 리턴하라.해결 방법런너 기법을 활용하여 절반의 리스트를 뒤집은 뒤, 팰린드롬을 비교한다.런너 기법은 리스트의 이동하는 두 개 이상의 포인터가 있을 때 이 포인터들의 이동 길이를 다르게 하는 기법이다.런너 기법을 사용하면 리스트의 1/2, 1/3 등으로 정확히 등분 하기 쉽다.해당 문제에서는 런너 기법을 활용하여, 리스트의 절반을 뒤집어 팰린드롬을 비교할 것이다.  리스트를 1칸 이동하는 slow포인터와 2칸 이동하는 fast포인터를 만들고, 역순을 저장하는 리스트를 만든다.  fast를 끝까지 이동시키면 slow는 정확히 절반을 이동한다.  리스트를 순회하면서 slow를 역순 리스트에 head로 만드는 과정을 반복하면 절반의 역순 리스트가 생성된다.  역순 리스트와 slow를 비교해 나가면 팰린드롬인지 확인이 가능하다.먼저, 역순 리스트를 만드는 과정을 그림으로 보자.이렇게 역순으로 만들었을 때, 리스트의 길이가 홀수여서 slow가 정확히 중앙에 위치하면, 한 칸 이동해야한다.다음으로 만들어진 역순리스트와 slow를 비교하는 과정을 그림으로 보자.풀이 코드// Definition for singly-linked list.export class ListNode {  val: number;  next: ListNode | null;  constructor(val?: number, next?: ListNode | null) {    this.val = val === undefined ? 0 : val;    this.next = next === undefined ? null : next;  }}export function isPalindrome(head: ListNode | null): boolean {  let reverseList = null;  let slow = head;  let fast = head;  while (fast &amp;&amp; fast.next) {    fast = fast.next.next;    const tmp = reverseList;    reverseList = new ListNode(slow.val, tmp);    slow = slow.next;  }  if (fast) {    slow = slow.next;  }  while (reverseList &amp;&amp; reverseList.val === slow.val) {    reverseList = reverseList.next;    slow = slow.next;  }  return !reverseList;}테스트 코드import { describe, expect, test } from '@jest/globals';import { isPalindrome, ListNode } from '.';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const input = new ListNode(      1,      new ListNode(2, new ListNode(2, new ListNode(1)))    );    const output = isPalindrome(input);    const expected = true;    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const input = new ListNode(1, new ListNode(2));    const output = isPalindrome(input);    const expected = false;    expect(output).toEqual(expected);  });});"
  },
  
  {
    "title": "Best Time to Buy and Sell Stock",
    "url": "/posts/best-time-to-buy-and-sell-stock/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-21 00:00:00 +0900",
    





    
    "snippet": "121. Best Time to Buy and Sell Stock문제 설명i번 째 날의 주식 가격이 prices[i]인 prices 배열이 주어진다.특정 날짜 하루를 지정 해서 주식을 사고, 주식을 산 날보다 미래의 다른 날짜에 주식을 팔아서 최대의 이익을 내고 싶다.해당 거래에서 달성 할 수 있는 가장 큰 이익을 리턴하고, 이익을 얻을 수 없으면 0...",
    "content": "121. Best Time to Buy and Sell Stock문제 설명i번 째 날의 주식 가격이 prices[i]인 prices 배열이 주어진다.특정 날짜 하루를 지정 해서 주식을 사고, 주식을 산 날보다 미래의 다른 날짜에 주식을 팔아서 최대의 이익을 내고 싶다.해당 거래에서 달성 할 수 있는 가장 큰 이익을 리턴하고, 이익을 얻을 수 없으면 0을 리턴하라.해결 방법최솟값을 갱신해 나가면서 현재 날짜와 최솟값의 차이를 계산한다.풀이 코드function maxProfit(prices: number[]): number {  let answer = 0;  let minPrice = Infinity;  for (let i = 0; i &lt; prices.length; i++) {    minPrice = Math.min(minPrice, prices[i]);    answer = Math.max(answer, prices[i] - minPrice);  }  return answer;}테스트 코드import { describe, expect, test } from '@jest/globals';import { maxProfit } from '.';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const output = maxProfit([7, 1, 5, 3, 6, 4]);    const expected = 5;    expect(output).toEqual(expected);  });  test('example test', () =&gt; {    const output = maxProfit([7, 6, 4, 3, 1]);    const expected = 0;    expect(output).toEqual(expected);  });});구현 후최솟값을 저장하기 위한 변수를 초기화 할 때, 보통 해당 언어에서 가장 큰 값을 저장하기 마련이다. 그런데 자바스크립트에서 Infininy가 가장 큰 수 인 줄 알았지만, 다른 답을 보면서 최댓값을 구할 때 여러가지 방법이 있다는 것을 알았다.  Number.MAX_VALUE는 부동소수점을 사용하여 나타낼 수 있는 가장 큰 수  Number.MAX_SAFE_INTEGER는 부동소수점을 사용하여 정확하게 나타낼 수 있는 수 중에서 가장 큰 수  Ifinity는 말 그대로 무한대이며, 이 보다 큰 숫자는 존재하지 않는다(표현이 불가능한 수를 나타냄)."
  },
  
  {
    "title": "Product of Array Except Self",
    "url": "/posts/product-of-array-except-self/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-20 00:00:00 +0900",
    





    
    "snippet": "238. Product of Array Except Self문제 설명정수 배열 nums가 주어질 때, result[i]는 nums[i]를 제외한 배열의 모든 숫자의 곱과 같게 하여 리턴하라.최대 숫자는 32-bit 정수임을 보장한다.시간 복잡도는 O(n)이내로 하고, 나눗셈을 사용할 수 없다.해결 방법result배열에 자기 자신을 기준으로 왼쪽과 오른...",
    "content": "238. Product of Array Except Self문제 설명정수 배열 nums가 주어질 때, result[i]는 nums[i]를 제외한 배열의 모든 숫자의 곱과 같게 하여 리턴하라.최대 숫자는 32-bit 정수임을 보장한다.시간 복잡도는 O(n)이내로 하고, 나눗셈을 사용할 수 없다.해결 방법result배열에 자기 자신을 기준으로 왼쪽과 오른쪽을 곱한다.해당 문제는 O(n)의 시간복잡도를 가져야 하기 때문에 이전의 값을 이용하는 일종의 DP를 사용해야 한다.  p라는 포인터 변수를 하나 두고, 해당 변수에 result에 저장하고, 오른쪽으로 곱해나간다.  p변수를 1로 다시 초기화 하고 오른쪽에서 시작하여 result에 곱하고, 왼쪽으로 곱해나간다.테스트케이스의 동작 과정은 아래와 같다.풀이 코드export function productExceptSelf(nums: number[]): number[] {  const result: number[] = [];  let p = 1;  for (let i = 0; i &lt; nums.length; i++) {    result.push(p);    p = p * nums[i];  }  p = 1;  for (let i = nums.length - 1; i &gt; 0 - 1; i--) {    result[i] = result[i] * p;    p = p * nums[i];  }  return result;}테스트 코드import { describe, expect, test } from '@jest/globals';import { productExceptSelf } from '.';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const output = productExceptSelf([1, 2, 3, 4]);    const expected = [24, 12, 8, 6];    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const output = productExceptSelf([-1, 1, 0, -3, 3]);    const expected = [0, 0, 9, 0, 0];    output.forEach((num, i) =&gt; expect(num === expected[i]).toEqual(true));  });});구현 후해당 문제는 생각하는게 어려웠지 막상 코드로 짜기는 쉬웠다.그런데 예상치도 못하게 테스트케이스에서 말썽을 부렸다.jest를 사용해서 자료구조 내부 값을 비교할 때 보통 toEqual을 많이 사용했다.그런데 두 번째 테스트케이스에서 곱해서 0으로 만드는 경우가 있다.자바스크립트에서는 음수 * 0 예로 들면, -5 * 0 = -0이다.이게 그냥 동등 비교할 때에는 true로 나오지만, toEqual에서는 다르다고 나온다.때문에 테스트케이스를 작성 할 때 꽤나 애를 먹었다.여러 가지 방법이 있지만 결국 가장 가독성이 좋은 동등 비교를 사용해서 테스트케이스를 작성했다.추가로, 해당 문제는 꽤나 오래 jest issue에 등록되어 있을 정도로 알려진 문제이므로 고쳐지기 전까지는 기억하고 있는 것이 좋겠다.Jest Issue link"
  },
  
  {
    "title": "Array Partition",
    "url": "/posts/array-partition/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-19 00:00:00 +0900",
    





    
    "snippet": "561. Array Partition문제 설명짝수개의 정수를 가진 배열이 주어질 때, 이 정수들을 n개의 페어 (a1, b1), (a2, b2), ..., (aN, bN)로 만들어 min(a, b)의 최대 합을 리턴하라.해결 방법정렬된 상태에서 인접한 요소와 페어를 만들게 되면 페어의 최솟값들의 합이 최대합이 된다.또, 정렬을 한 상태에서 페어를 만들...",
    "content": "561. Array Partition문제 설명짝수개의 정수를 가진 배열이 주어질 때, 이 정수들을 n개의 페어 (a1, b1), (a2, b2), ..., (aN, bN)로 만들어 min(a, b)의 최대 합을 리턴하라.해결 방법정렬된 상태에서 인접한 요소와 페어를 만들게 되면 페어의 최솟값들의 합이 최대합이 된다.또, 정렬을 한 상태에서 페어를 만들게 되면 최솟값이 항상 왼쪽에 위치하기 때문에 인덱스 0부터 2칸 씩 이동하면 최솟값이 된다.테스트 케이스를 예로 들면,  [6, 2, 6, 5, 1, 2]를 정렬한다.  [1, 2, 2, 5, 6, 6]의 2n 번 째 값을 모두 더한다.  1 + 2 + 6이므로 답은 9가 된다.풀이 코드function arrayPairSum(nums: number[]): number {  let answer = 0;  const sortedNums = nums.sort((a, b) =&gt; a - b);  for (let i = 0; i &lt; sortedNums.length; i += 2) {    answer += sortedNums[i];  }  return answer;}테스트 코드import { describe, expect, test } from '@jest/globals';import { arrayPairSum } from '.';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const output = arrayPairSum([1, 4, 3, 2]);    const expected = 4;    expect(output).toEqual(expected);  });  test('example test', () =&gt; {    const output = arrayPairSum([6, 2, 6, 5, 1, 2]);    const expected = 9;    expect(output).toEqual(expected);  });});"
  },
  
  {
    "title": "3Sum",
    "url": "/posts/three-sum/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-18 00:00:00 +0900",
    





    
    "snippet": "15. 3Sum문제 설명정수 배열이 주어질 때, 3개의 엘리먼트가 i != j, i != k, j != k이고,nums[i] + nums[j] + nums[k] === 0인 경우를 모두 찾으시오.결과에 중복이 존재해서는 안된다.해결 방법투 포인터 탐색을 진행하기 위해 주어진 배열을 오름차순으로 정렬한다.배열을 순회할 때, 인덱스 i를 기준으로 left...",
    "content": "15. 3Sum문제 설명정수 배열이 주어질 때, 3개의 엘리먼트가 i != j, i != k, j != k이고,nums[i] + nums[j] + nums[k] === 0인 경우를 모두 찾으시오.결과에 중복이 존재해서는 안된다.해결 방법투 포인터 탐색을 진행하기 위해 주어진 배열을 오름차순으로 정렬한다.배열을 순회할 때, 인덱스 i를 기준으로 left = i + 1, right = nums.length - 1로 기준을 두고, 투 포인터 탐색을 진행한다.  현재 세 숫자를 더한다.  합이 0보다 작으면 left를 오른쪽으로 한 칸 옮긴다.  합이 0보다 크면 right를 왼쪽으로 한 칸 옮긴다.  0일 경우 결과에 저장하고, left와 right에 중복만큼 포인터를 넘긴다.풀이 코드export function threeSum(nums: number[]): number[][] {  const result: number[][] = [];  nums.sort((a, b) =&gt; a - b);  for (let i = 0; i &lt; nums.length - 2; i++) {    if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;    let left = i + 1;    let right = nums.length - 1;    while (left &lt; right) {      const sum = nums[i] + nums[left] + nums[right];      if (sum &lt; 0) left++;      else if (sum &gt; 0) right--;      else {        result.push([nums[i], nums[left], nums[right]]);        while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) left++;        while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right--;        left++;        right--;      }    }  }  return result;}테스트 코드import { describe, expect, test } from '@jest/globals';import { threeSum } from '.';describe(' description', () =&gt; {  test('example test 1', () =&gt; {    const output = threeSum([-1, 0, 1, 2, -1, -4]);    const expected = [      expect.arrayContaining([-1, -1, 2]),      expect.arrayContaining([-1, 0, 1]),    ];    expect(output).toEqual(expected);  });  test('example test 2', () =&gt; {    const output = threeSum([0, 1, 1]);    const expected = [];    expect(output).toEqual(expected);  });  test('example test 3', () =&gt; {    const output = threeSum([0, 0, 0]);    const expected = [[0, 0, 0]];    expect(output).toEqual(expected);  });});"
  },
  
  {
    "title": "Trapping Rain Water",
    "url": "/posts/trapping-rain-water/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-17 00:00:00 +0900",
    





    
    "snippet": "42. Trapping Rain Water문제 설명각각의 막대의 너비가 1인 높이를 나타내는 자연수 n이 주어질 때, 비가 온 후 물을 얼마나 담을 수 있는지 계산하라.해결 방법투 포인터를 활용하여 왼쪽과 오른쪽에서 현재 높이와 최대 높이의 차이 만큼을 더해나간다.  양 쪽 모두 최대 높이와 현재 높이를 비교해 최대 높이를 갱신한다.  최대 높이를 서...",
    "content": "42. Trapping Rain Water문제 설명각각의 막대의 너비가 1인 높이를 나타내는 자연수 n이 주어질 때, 비가 온 후 물을 얼마나 담을 수 있는지 계산하라.해결 방법투 포인터를 활용하여 왼쪽과 오른쪽에서 현재 높이와 최대 높이의 차이 만큼을 더해나간다.  양 쪽 모두 최대 높이와 현재 높이를 비교해 최대 높이를 갱신한다.  최대 높이를 서로 비교해 너 높은 쪽으로 낮은 쪽이 이동하는 방식으로 진행한다.  진행하면서 현재 높이가 최대 높이보다 낮으면 빗물을 받을 수 있으므로 결과값에 더한다.풀이 코드export function trap(height: number[]): number {  let answer = 0;  let left = 0;  let right = height.length - 1;  let leftMax = height[left];  let rightMax = height[right];  while (left &lt; right) {    leftMax = Math.max(leftMax, height[left]);    rightMax = Math.max(rightMax, height[right]);    if (leftMax &lt;= rightMax) {      answer += leftMax - height[left];      left++;    } else {      answer += rightMax - height[right];      right--;    }  }  return answer;}테스트 코드import { describe, expect, test } from '@jest/globals';import { trap } from '.';describe(' description', () =&gt; {  test(' test example 1', () =&gt; {    const output = trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]);    const expected = 6;    expect(output).toEqual(6);  });  test(' test example 2', () =&gt; {    const output = trap([4, 2, 0, 3, 2, 5]);    const expected = 9;    expect(output).toEqual(9);  });});"
  },
  
  {
    "title": "vscode에서 lazygit 사용하기",
    "url": "/posts/vscode-lazygit/",
    "categories": "editor",
    "tags": "vscode",
    "date": "2023-02-16 00:00:00 +0900",
    





    
    "snippet": "Intro요즘 vscode를 설정하는데 푹 빠져있다.원래 더 자유도가 높고, 마우스도 잘 안쓰는 neovim을 쓰려고 했는데, 컴퓨터가 안좋은 탓인지 몰라도 커맨드를 여러 개 중첩시키면 제대로 동작하지 않는 현상이 벌어진다.예로 들면, 전체 선택을 하기 위해 커서를 파일 끝으로 옮기고, 선택 모드로 진입 후 첫 라인으로 이동, 그리고 커서를 앞으로 옮...",
    "content": "Intro요즘 vscode를 설정하는데 푹 빠져있다.원래 더 자유도가 높고, 마우스도 잘 안쓰는 neovim을 쓰려고 했는데, 컴퓨터가 안좋은 탓인지 몰라도 커맨드를 여러 개 중첩시키면 제대로 동작하지 않는 현상이 벌어진다.예로 들면, 전체 선택을 하기 위해 커서를 파일 끝으로 옮기고, 선택 모드로 진입 후 첫 라인으로 이동, 그리고 커서를 앞으로 옮기는 커맨드를 만들었는데, 제대로 동작하지 않았다. 아마 딜레이를 주고 어쩌고 하다보면 될 테지만, 한국어 자료도 별로 없는 neovim을 잘 쓸 자신도 없고, 익숙하지 않아서 그런가 생산성도 떨어지는 기분이 들었다.해서 vscode로 다시 넘어왔다.그런데 이거 보세요…이게 2023년도에 git을 지원하는 에디터 맞습니까? ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ물론 여러가지 확장을 쓰게 되면, 진짜 좋아지긴 하지만 단 한가지 커밋 작성에 대해서는 정말 꽝이다.이래저래 찾아봐도 뭐가 없었고, 내심 인텔리제이에서 사용하는 코드 단위 커밋은 정말 써보고 싶은데 유료라서 사용할 엄두가 안 난다.그래도 뭐 깃을 쓸 때는 소스트리나 lazygit을 쓰면 되니깐 문제가 없는데, 이걸 켜고 끄는 것 마저 귀찮아지기 시작했다.그래서 몇날을 고민한 끝에 ‘아 내가 그냥 vscode 확장을 만들어야겠다.’ 생각했다.고민먼저, 소스트리는 자체 실행 파일이기 때문에 제외를 했고, ‘lazygit을 어떻게 하면 vscode에서 바로 실행되게 할 수 있을까?’를 고민했다.내가 원하는 것은 vscode는 하단에 자체 터미널 탭을 가지고 있기 때문에 이걸 최대화 시킨 후, lazygit 명령어를 실행시키는 것이다.근데 중요한 점은 내가 extension을 한 번도 만들어 본 적이 없어서 이걸 만드는데 얼마나 걸릴지 알 수가 없다는 것이다.그래서 뭐 여차저차 구글 검색을 때려본 결과 이미 나와 같은 생각을 하고 있는 사람을 찾았다.해당 블로그 글은 vscode task를 만들어서 lazygit을 띄우는 명령어를 만드는 것인데,,,여기서 문제는 저 명령어를 실행시키면 터미널에 포커스를 두는 것과 터미널 창을 최대화 시키는 것은 또 따로 해야하는 것이다.나는 하나의 단축키로 터미널 포커스, 최대화, lazygit 실행을 하고 싶은데 말이지… 그러다가 우연히 진짜 대박인 확장을 찾았다.간략하게 설명하자면 커맨드 여러 개를 한 루틴에 묶을 수 있는 확장인데, 내가 딱 원하던 거다!해결와 이 확장을 찾은건 정말 천운이나 다름없다.이게 진짜 대박인게 이걸 잘만 사용하면 vscode를 vim처럼 사용할 수 있다.일단 추후에 그렇게 만들도록하고, 내가 지금 원하는 걸 해야지.해당 확장으로 다중 커맨드를 사용하는 법은 간단하다.먼저 settings.json에 사용할 커맨드를 등록하고, keybindings.json에서 바인딩만 해주면 끝이다.코드로 보면 아래와 같다.settings.json[  \"multiCommand.commands\": [    {      \"command\": \"startLazygit\",      \"sequence\": [        \"workbench.action.toggleMaximizedPanel\",        \"terminal.focus\",        {          \"command\": \"workbench.action.terminal.sendSequence\",          \"args\": { \"text\": \"lazygit\\n\", \"delay\": 100 }        }      ]    }  ]]keybindings.json[  {    \"key\": \"cmd+ctrl+l\",    \"command\": \"extension.multiCommand.execute\",    \"args\": {        \"command\": \"startLazygit\"     },  }]먼저 settings.json에 사용할 command를 등록해주고, sequence에 내가 원하는 vscode command를 순차적으로 작성해주고, keybindings.json에서 저렇게 등록해주기만 하면 잘 실행된다.여기서 주의할 점은 기존 바인딩 할 때 커맨드를 커스텀한 커맨드로 작성하는게 아니고, 기존 커맨드는 extension.multiCommand.execute를 넣어주고, 인자로 커스텀 커맨드를 넣어주는 것이다.나는 cmd+ctrl+l에 매핑했고, 실행하고 나서 지렸다.실행 하기 전에 이 화면이었다면, 실행하게 되면…Awesome미쳐버리겠다. 내 일주일 동안의 고민을 한 번에 해결해주신 개발자 ryuta46님 정말 감사드립니다!!!후기아직 저 커맨드는 엉뚱한 작동을 할 가능성이 높다. 그럼에도 너무 흥분한 나머지 이 확장을 전파하고자 해당 게시글을 작성했다.엉뚱한 작동은 현재 터미널이 다른 디렉토리에 있어도 현재 워크 스페이스가 아닌 다른 위치에서 lazygit이 실행 될 것이다.뭐, 그 정도는 다른 터미널 세션을 띄우는 작업을 넣는다던지, 현재 위치로 가도록 하는 커맨드를 넣는다던지 해서 쉽게 해결할 수 있으니깐…이 확장을 잘만 사용하면 여러 커맨드를 잘 중첩시켜 진짜 대박인 커맨드를 만들어낼 수 있겠다."
  },
  
  {
    "title": "Two Sum",
    "url": "/posts/two-sum/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-16 00:00:00 +0900",
    





    
    "snippet": "1. Two Sum문제 설명숫자 nums 배열과 타겟 숫자가 주어질 때, 배열의 두 숫자를 합하여 타겟이 되는 인덱스를 반환하라.각각의 입력에는 하나의 솔루션만 있고, 같은 요소를 두 번 사용할 수 없다.정답을 반환 할 때, 정렬은 필요없다.해결 방법반복문을 돌며 타겟에서 현재 값을 빼면 나머지 값이 나오기 때문에 이를 배열에서 찾지말고, object...",
    "content": "1. Two Sum문제 설명숫자 nums 배열과 타겟 숫자가 주어질 때, 배열의 두 숫자를 합하여 타겟이 되는 인덱스를 반환하라.각각의 입력에는 하나의 솔루션만 있고, 같은 요소를 두 번 사용할 수 없다.정답을 반환 할 때, 정렬은 필요없다.해결 방법반복문을 돌며 타겟에서 현재 값을 빼면 나머지 값이 나오기 때문에 이를 배열에서 찾지말고, object에 저장해서 한 번에 찾도록 한다.object에 저장할 때에는 [ 현재 값: index ]로 저장하도록 한다.풀이 코드export function twoSum(nums: number[], target: number): number[] {  const numsObj = {};  for (let i = 0; i &lt; nums.length; i++) {    if (numsObj[target - nums[i]] &gt;= 0) return [numsObj[target - nums[i]], i];    numsObj[nums[i]] = i;  }}테스트 코드import { describe, expect, test } from '@jest/globals';import { twoSum } from '.';describe('two sum test describe', () =&gt; {  test('test case 1', () =&gt; {    expect(twoSum([2, 7, 11, 15], 9)).toEqual(expect.arrayContaining([0, 1]));  });  test('test case 2', () =&gt; {    expect(twoSum([3, 2, 4], 6)).toEqual(expect.arrayContaining([1, 2]));  });  test('test case 3', () =&gt; {    expect(twoSum([3, 3], 6)).toEqual(expect.arrayContaining([0, 1]));  });});"
  },
  
  {
    "title": "Longest Palindromic Substring",
    "url": "/posts/longest-palindromic-substring/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-15 00:00:00 +0900",
    





    
    "snippet": "5. Longest Palindromic Substring문제 설명문자열 s가 주어질 때, 부분 문자열 중 가장 긴 팰린드롬을 리턴하라.해결 방법  부분 문자열의 팰린드롬을 확인하는 expand 함수를 정의한다.          expand는 left와 right를 투포인터로 받아 양쪽으로 확장하면서 팰린드롬을 체크한다.        입력받은 문자열이...",
    "content": "5. Longest Palindromic Substring문제 설명문자열 s가 주어질 때, 부분 문자열 중 가장 긴 팰린드롬을 리턴하라.해결 방법  부분 문자열의 팰린드롬을 확인하는 expand 함수를 정의한다.          expand는 left와 right를 투포인터로 받아 양쪽으로 확장하면서 팰린드롬을 체크한다.        입력받은 문자열이 자체 팰린드롬인지 검사한다.          s의 길이가 2 미만 또는 전체가 팰린드롬 일 경우 문자열 전체를 반환한다.        문자열을 순회하면서 최장 길이 부분 문자열 팰린드롬을 탐색한다.          현재 최장길이와 현재 index부터 팰린드롬을 탐색하여 비교한다.      부분 문자열을 탐색할 때 홀수의 길이와 짝수의 길이는 시작 위치가 다르므로 각각 탐색한다.      index가 2일 때 탐색 방법이다.홀수 탐색짝수 탐색(방식을 보여주는 것일 뿐 실제로 다르다면 다음으로 넘어가지 않는다.)풀이 코드function isPalindrome(s: string): boolean {  for (let i = 0; i &lt; Math.floor(s.length / 2); i++) {    if (s[i] !== s[s.length - 1 - i]) return false;  }  return true;}export function longestPalindrome(s: string): string {  const expand = (left: number, right: number): string =&gt; {    while (left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) {      left -= 1;      right += 1;    }    return s.slice(left + 1, right);  };  let answer = '';  if (s.length &lt; 2 || isPalindrome(s)) return s;  for (let i = 0; i &lt; s.length - 1; i++) {    answer = [answer, expand(i, i + 1), expand(i, i + 2)].sort(      (a, b) =&gt; b.length - a.length    )[0];  }  return answer;}테스트 코드import { describe, expect, test } from '@jest/globals';import { longestPalindrome } from '.';describe(' description', () =&gt; {  test('example test case1', () =&gt; {    const output = longestPalindrome('babad');    const expectedOutput = 'bab';    expect(output).toEqual(expectedOutput);  });  test('example test case2', () =&gt; {    const output = longestPalindrome('cbbd');    const expectedOutput = 'bb';    expect(output).toEqual(expectedOutput);  });});"
  },
  
  {
    "title": "chatGpt를 통한 테스트코드 작성",
    "url": "/posts/chatGpt%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1/",
    "categories": "typescript",
    "tags": "testcode",
    "date": "2023-02-15 00:00:00 +0900",
    





    
    "snippet": "Intro리트코드의 Group Anagrams라는 문제를 풀다가 테스트코드를 작성하는데 지문에 이런 문구가 있다.  You can return the answer in any order.어떠한 순서로도 반환할 수 있다.이럴 때 jest로 테스트코드를 작성한다고 하면 어떻게 작성해야되는지 의문이 들었다.그런데 애초에 키워드 자체를 모르는데 어떻게 검색을...",
    "content": "Intro리트코드의 Group Anagrams라는 문제를 풀다가 테스트코드를 작성하는데 지문에 이런 문구가 있다.  You can return the answer in any order.어떠한 순서로도 반환할 수 있다.이럴 때 jest로 테스트코드를 작성한다고 하면 어떻게 작성해야되는지 의문이 들었다.그런데 애초에 키워드 자체를 모르는데 어떻게 검색을 할 수 있나… ㅋㅋ그래서 jest 공식문서 몇 번 깔짝거리다가 검색 몇 번 해보고 Gpt한테 물어봤다.어허 너무 쉽잖아 jest로 ‘해줘(애초에 정확하지 않기도 함).’describe(\"groupAnagrams\", () =&gt; {  test(\"example test case\", () =&gt; {    const input = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"];    const output = groupAnagrams(input);    const expectedOutput = [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]];    expect(output).toEqual(expect.arrayContaining(expectedOutput));  });  test(\"returns empty array when input is empty array\", () =&gt; {    const input: string[] = [];    const output = groupAnagrams(input);    const expectedOutput: string[][] = [];    expect(output).toEqual(expectedOutput);  });  ...});이렇게 답변 해줬다. 이 때 arrayContaining이라는 키워드를 확인했고, 이미 이 때 끝난거나 다름없다.그런데 해당 테스트코드는 완전히 정답은 아니고 일부는 커버하지 못한다.만약 아래와 같은 정답이 있을 때 Gpt가 알려준 테스트코드는 정답을 통과하지 못한다.[[\"eat\", \"tea\", \"ate\"], [\"nat\", \"tan\"], [\"bat\"]]해당 반환 값이 리트코드에서는 정답이다.그럼 과연 chatGpt는 몇 번만에 테스트코드를 정확하게 작성 할 수 있는지 궁금해졌고, 몇 번 물어봤다.갑자기 자기 멋대로 문제를 해석하기 시작해서 힌트를 주었다.그냥 이건 expectedOutput의 순서만 바뀐거잖아ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ영어로 물어봤으면 정확하게 대답했을까? 그냥 아예 정답에 가까운 질문을 해봤다.오… 결국 3번만에 정확한 테스트코드를 작성했다.구글 검색으로 찾았으면 키워드 찾는데만 수 십분을 썼을 수도 있다.그런데 키워드 찾는데 질문 한 번, 정확한 코드를 작성하는데 질문 4번이 소요되었다.솔직히 구글 검색보다 쉬운거 인정한다.그런데 몇 번 틀리는 것을 보니 chatGpt의 표본이 결국 구글에서 검색되는 많은 자료들이 아닐까 싶다.이걸 보면서 인터넷에 얼마나 많은 오류들이 떠돌아 다니는지 새삼 다시 깨닫게 되었다.그래도 나는 이러한 오류를 작성하는 사람들을 비판할 생각도 없을 뿐더러,틀릴 수 있다는 공포를 이겨내고 블로그를 작성해서 남들에게 자신의 자료를 공개하는 분들에게 존경심을 표한다.또한, 그러한 방대한 자료, 오류들이 없었으면 chatGpt도 없었겠지.칭찬 또한 잊지 말고 해주자!"
  },
  
  {
    "title": "vscode에서 typescript 디버깅",
    "url": "/posts/typescript-debugging-in-vscode/",
    "categories": "typescript",
    "tags": "debugging",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "INTROvscode에서 타입스크립트를 디버깅하는 방법은 인터넷에도 많이 나와있고, vscode 공식문서에도 나와있다.그래서 생략하고, 나머지 내가 난관에 봉착했던 것들을 기록하려한다.vscode 공식문서문제 상황알고리즘 문제를 풀던 도중 긴가민가하는 문제가 생겨서 디버깅을 해야하는 상황이 생겼다.그래서 위의 문서에 나와있는대로 디버깅을 하려하니 빌드...",
    "content": "INTROvscode에서 타입스크립트를 디버깅하는 방법은 인터넷에도 많이 나와있고, vscode 공식문서에도 나와있다.그래서 생략하고, 나머지 내가 난관에 봉착했던 것들을 기록하려한다.vscode 공식문서문제 상황알고리즘 문제를 풀던 도중 긴가민가하는 문제가 생겨서 디버깅을 해야하는 상황이 생겼다.그래서 위의 문서에 나와있는대로 디버깅을 하려하니 빌드는 되는데 실행이 잘 안된다.검색을 해보니 task파일을 만들어야 한다더라… 어케 찾은건지;;참고 블로그그러고 나서 실행해보니 잘 되긴 되는데, 한 가지 문제가 생겼다.나는 따로 푼 문제들을 언어별로 관리를 하는데, typescript에서는 최초로 테스트코드를 도입해보려는 시도를 했다.그래서 아무 생각없이 루트 디렉토리에 tsconfig와 jest.config.js를 생성했는데,이렇게 하고 디버깅을 하려고 보니 모든 디렉토리에 빌드 파일이 생기는 것이다…사실 이렇게 빌드가 되던 말던 상관없었다.find와 rm을 조합 한 후 다 찾아서 지워버리면 그만이다.그런데 일주일 전이었나 mysql을 항상 도커에서 쓰다가 로컬에서 쓰려니 비밀번호를 까먹었다.어차피 로컬에 저장된 데이터도 없을 뿐더러 잘 사용하지 않으니깐 밀었다가 다시 설치하려고 무려 root에서!!!find / -name mysql -type d -exec rm {} \\;를 사용했다(왠만하면 쓰지맙시다.).그런데 예상치 못한 node에 mysql 디렉터리가 있었던 것이다.한 번 find 해보고 할걸…결국 에러를 해결 못하고, 포맷했는데 그 때 이후로 rm은 되도록 자제하려고 한다.해결 방법애초에 타겟만 빌드되도록 하는 것이 좋아보여서 이것 저것 만져봤는데 도통 감이 안잡혔다.결국 어떻게 하는 지 몰라서 그냥 tsconfig에 빌드 목적지 두고 빌드 파일을 따로 한 곳에 모아놓은 뒤 나중에 끝나면 삭제하는 식으로 진행했다.마무리아래와 같은 디렉토리 구조를 가지고 있다고 할 때,most-common-word/index.ts를 디버깅 하고 싶다면 아래와 같이 설정했다.algorithm├─ .vscode├─ javascript├─ python└─ typescript   ├─ String-Manipulation   │  ├─ most-common-word   │  │  ├─ index.test.ts   │  │  └─ index.ts   │  ├─ reorder-data-in-log-files   │  │  ├─ index.test.ts   │  │  └─ index.ts   ├─ jest.config.js   ├─ tsconfig.json// tsconfig.json{    \"compilerOptions\":{        \"target\": \"ES2019\",        \"sourceMap\": true,        \"rootDir\": \"./\",        // 빌드 시 생성되는 파일 위치를 지정한다. 시작 위치는 tsconfig.json이 위치한 디렉토리        \"outDir\": \"dist\"    }}// .vscode/launch.json{    \"version\": \"0.2.0\",    \"configurations\": [        {            \"type\": \"node\",            \"request\": \"launch\",            \"name\": \"Launch Program\",            \"skipFiles\": [                \"&lt;node_internals&gt;/**\"            ],            // 타겟의 위치를 입력한다. workspaceFolder는 .vscode가 있는 디렉토리다.            \"program\": \"${workspaceFolder}/typescript/String-Manipulation/most-common-word/index.ts\",            \"outFiles\": [                // 여기에 빌드 된 파일의 위치를 지정한다.                \"${workspaceFolder}/typescript/dist/**/*.js\"            ],            \"preLaunchTask\": \"tsc: build - typescript/tsconfig.json\"        }    ]}// .vscode/tasks.json{    \"version\": \"2.0.0\",    \"tasks\": [        {            \"type\": \"typescript\",            \"tsconfig\": \"typescript/tsconfig.json\",            \"group\": \"build\",            \"label\": \"tsc: build - typescript/tsconfig.json\"        }    ]}분명히 tsconfig를 어떻게 만지면 내가 원하는 디렉토리만 빌드 할 수 있을 것 같은데, 추후 알아보자."
  },
  
  {
    "title": "Group Anagrams",
    "url": "/posts/group-anagrams/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "49. Group Anagrams문제 설명문자열로 이루어진 배열이 주어질 때, 애너그램 단위로 그룹화 묶어라.정달을 반환할 때에는 정렬은 고려하지 않아도 된다.애너그램은 일반적으로 모든 오리지널 문자를 한 번씩만 사용하여 다른 단어나 구를 재배치하여 형성된 단어나 구이다.예를 들면, eat과 tea는 같은 애너그램 그룹이다.해결 방법  애너그램을 그룹...",
    "content": "49. Group Anagrams문제 설명문자열로 이루어진 배열이 주어질 때, 애너그램 단위로 그룹화 묶어라.정달을 반환할 때에는 정렬은 고려하지 않아도 된다.애너그램은 일반적으로 모든 오리지널 문자를 한 번씩만 사용하여 다른 단어나 구를 재배치하여 형성된 단어나 구이다.예를 들면, eat과 tea는 같은 애너그램 그룹이다.해결 방법  애너그램을 그룹화 하기 위해 현재 단어를 오름차순으로 정렬한 단어를 key 값으로 사용한다.          example: eat =&gt; aet        각 애너그램 key의 value는 배열로 세팅한다.  각 단어들을 key값에 따라 value에 넣는다.  object 자료구조에서 value를 추출해 리턴한다.풀이 코드function groupAnagrams(strs: string[]): string[][] {  const anagrams = {};  for (let str of strs) {    const key = str.split('').sort().join('');    if (!anagrams[key]) anagrams[key] = [];    anagrams[key].push(str);  }  return Object.values(anagrams);}테스트 코드import { describe, expect, test } from '@jest/globals';import { groupAnagrams } from '.';describe(' description', () =&gt; {  test('example test case', () =&gt; {    const input = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat'];    const output = groupAnagrams(input);    const expectedOutput = [      expect.arrayContaining(['eat', 'tea', 'ate']),      expect.arrayContaining(['tan', 'nat']),      expect.arrayContaining(['bat']),    ];    expect(output).toEqual(expect.arrayContaining(expectedOutput));  });  test('none input test', () =&gt; {    const result = groupAnagrams(['']);    expect(result).toEqual([['']]);  });  test('one input test', () =&gt; {    const result = groupAnagrams(['a']);    expect(result).toEqual([['a']]);  });});구현 후이 문제는 사실 별로 어렵지는 않았다.그런데 어떠한 정렬 상태도 테스트케이스를 통과해야되기 때문에 테스트 케이스를 작성하는데 어려움이 있었다.테스트케이스 작성은 처음이다보니 어떠한 매처들이 있는지 찾기 힘들었고, chatGpt를 활용했다.chatGpt를 활용하니 arrayContaining이라는 매처를 찾아줬고, 아주 쉽게 테스트케이스를 작성할 수 있었다.구글 검색으로는 어떻게 검색해야 될지 몰라서 헤맸는데, 아무리 봐도 Gpt는 놀라움의 연속이다.사실 처음부터 맞는 테스트케이스를 찾아준 것은 아니지만 여러 번 수정을 해주니 원하는 정답을 찾아줬다.chatGpt와 소통 과정을 한 번 포스팅 해야겠다."
  },
  
  {
    "title": "Most Common Word",
    "url": "/posts/most-common-word/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-13 00:00:00 +0900",
    





    
    "snippet": "819. Most Common Word문제 설명문자열로 된 문장과 금지어 목록이 배열로 주어질 때, 금지어가 아니면서 가장 많이 등장하는 단어를 리턴하라.적어도 한 단어는 금지어로 지정되어 있지 않고, 정답은 하나 뿐이다.문장의 단어들은 대소문자가 구분되어 있지 않고, 정답은 소문자로 반환되어야 한다.해결 방법  주어진 문장을 배열로 파싱한다.    ...",
    "content": "819. Most Common Word문제 설명문자열로 된 문장과 금지어 목록이 배열로 주어질 때, 금지어가 아니면서 가장 많이 등장하는 단어를 리턴하라.적어도 한 단어는 금지어로 지정되어 있지 않고, 정답은 하나 뿐이다.문장의 단어들은 대소문자가 구분되어 있지 않고, 정답은 소문자로 반환되어야 한다.해결 방법  주어진 문장을 배열로 파싱한다.          주어진 문장을 소문자로 바꾼다.      알파벳이 아닌 문자를 공백으로 변환한다.      공백을 기준으로 문장을 분리한다.        단어의 숫자를 카운트 하기 위해 배열을 순회하며 object 자료형에 [word: count]형태로 저장한다.          저장할 때 금지어는 생략한다.        object의 key 값을 추출하여 가장 많이 등장한 단어를 찾는다.풀이 코드export function mostCommonWord(paragraph: string, banned: string[]): string {  const words = paragraph.toLowerCase().replace(/[^\\w]/g, ' ').split(' ');  let wordsObj = {};  let mostWord = '';  let mostCount = 0;  for (let word of words) {    if (word.length === 0 || banned.includes(word)) continue;    if (!wordsObj[word]) wordsObj[word] = 0;    wordsObj[word]++;  }  Object.keys(wordsObj).forEach((word) =&gt; {    if (mostCount &lt; wordsObj[word]) {      mostWord = word;      mostCount = wordsObj[word];    }  });  return mostWord;}테스트 코드import { describe, expect, test } from '@jest/globals';import { mostCommonWord } from '.';describe(' description', () =&gt; {  test(' test description', () =&gt; {    const value = mostCommonWord(      'Bob hit a ball, the hit BALL flew far after it was hit.',      ['hit']    );    expect(value).toEqual('ball');  });  test(' test description', () =&gt; {    const value = mostCommonWord('a.', []);    expect(value).toEqual('a');  });});구현 후더 최적화 할 방법이 있어보이는 코드이다.하지만 충분히 빠르고, 쉬워보이기도 하니 넘어가도록 하자(Hint: 반복문 하나로 처리).파싱에서 긴가민가하는 부분이 있어서 ts 사용 최초로 디버깅을 시도했는데,node환경에서는 ts 디버깅을 바로 지원하지 않고 js로 트랜스컴파일(빌드) 후 디버깅을 하는 것 같다.그런데 테스트를 간편하게 하기 위해서 루트 디렉토리에 tsconfig와 jest.config.js 파일을 두었더니,루트부터 전체가 트랜스파일 되는 현상이 있었다.특정 디렉토리만 타겟으로 트랜스컴파일을 하려고 하니 뭔가 어렵다.이게 문제가 되는 이유는, 디버깅 후 찌꺼기 파일들을 다 삭제해야하는데 너무 귀찮다.find에 rm 명령어를 써도 되긴 하겠지만(옛날에 한 번 root에서 썻다가 포맷했던 적이 있어서 그런가 무서웠다.),일단은 outDir옵션을 사용해 따로 한곳에 모아둔 뒤 삭제하기로 했다.일단, 특정 디렉토리만 빌드하는 것은 나중에 찾아보기로 하고, 넘어가자."
  },
  
  {
    "title": "Reorder Data in Log Files",
    "url": "/posts/reorder-data-in-log-files/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-12 00:00:00 +0900",
    





    
    "snippet": "937. Reorder Data in Log Files문제 설명log 배열이 주어진다. 각각의 로그는 공백으로 구분되어있고, 첫 번째 단어는 식별자다.로그에는 두 가지 타입이 있다.  Letter-logs: 모든 단어(식별자 제외)는 소문자로 구성되어 있다.  Digit-logs: 모든 단어(식별자 제외)는 숫자로 구성되어 있다.로그를 재정렬 하는 방...",
    "content": "937. Reorder Data in Log Files문제 설명log 배열이 주어진다. 각각의 로그는 공백으로 구분되어있고, 첫 번째 단어는 식별자다.로그에는 두 가지 타입이 있다.  Letter-logs: 모든 단어(식별자 제외)는 소문자로 구성되어 있다.  Digit-logs: 모든 단어(식별자 제외)는 숫자로 구성되어 있다.로그를 재정렬 하는 방법  문자 로그는 숫자 로그보다 앞에 온다.  문자 로그는 사전 순으로 정렬되어 있다. 내용이 같다면, 식별자 기준으로 정렬한다.  숫자 로그는 입력 순으로 정렬한다.위 방법으로 재정렬 된 로그 배열을 리턴하라.해결 방법  입력 받은 로그 배열을 문자와 숫자 로그로 분리한다.  문자 로그는 사전 순으로 재 정렬한다.  문자 로그 뒤에 숫자 로그를 합친다.풀이 코드function reorderLogFiles(logs: string[]): string[] {  const stringLog: string[] = [];  const numberLog: string[] = [];  for (let log of logs) {    const isString = isNaN(Number(log.split(\" \")[1]));    if (isString) stringLog.push(log);    else numberLog.push(log);  }  stringLog.sort((a: string, b: string): number =&gt; {    let aLog = a.substring(a.indexOf(\" \") + 1);    let bLog = b.substring(b.indexOf(\" \") + 1);    if (aLog !== bLog) return aLog.localeCompare(bLog);    return a.localeCompare(b);  });  return stringLog.concat(numberLog);}테스트 코드import { describe, expect, test } from \"@jest/globals\";import { reorderLogFiles } from \".\";describe(\"reorder log files describe\", () =&gt; {  test(\"test1\", () =&gt; {    expect(      reorderLogFiles([        \"dig1 8 1 5 1\",        \"let1 art can\",        \"dig2 3 6\",        \"let2 own kit dig\",        \"let3 art zero\",      ])    ).toEqual([      \"let1 art can\",      \"let3 art zero\",      \"let2 own kit dig\",      \"dig1 8 1 5 1\",      \"dig2 3 6\",    ]);  });  test(\"test1\", () =&gt; {    expect(      reorderLogFiles([        \"a1 9 2 3 1\",        \"g1 act car\",        \"zo4 4 7\",        \"ab1 off key dog\",        \"a8 act zoo\",      ])    ).toEqual([      \"g1 act car\",      \"a8 act zoo\",      \"ab1 off key dog\",      \"a1 9 2 3 1\",      \"zo4 4 7\",    ]);  });});구현 후파이썬과 다르게 자바스크립트에서는 sort에서 상당히 애를 먹었다.사실 localeCompare의 존재도 몰랐고, 다중 조건으로 cb을 짜는 부분이 어려웠다.내가 알고리즘 문제를 푸는 이유도 알고리즘에 대한 이해도를 높이기 위함도 있지만,문제를 풀다 보면 언어의 특성에 대해 알 수 있어서다.또, ts로 하면서 console로 테스트하지 않고 jest를 이용해 test코드를 짜보는 연습을 하고 있다.그런데 계속 하드 코딩으로 인자를 비교해야하는지 한 번 찾아볼 필요가 있겠다."
  },
  
  {
    "title": "Reverse String",
    "url": "/posts/reverse-string/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-11 00:00:00 +0900",
    





    
    "snippet": "344. Reverse String문제 설명문자열을 뒤집는 함수를 작성하라.추가적인 메모리 사용없이 리스트를 직접 조작하여야 한다.해결 방법리스트의 절반을 순회하여 앞과 뒤를 바꾼다.풀이 코드function reverseString(s: string[]): void {  for (let i = 0; i &lt; Math.floor(s.length / ...",
    "content": "344. Reverse String문제 설명문자열을 뒤집는 함수를 작성하라.추가적인 메모리 사용없이 리스트를 직접 조작하여야 한다.해결 방법리스트의 절반을 순회하여 앞과 뒤를 바꾼다.풀이 코드function reverseString(s: string[]): void {  for (let i = 0; i &lt; Math.floor(s.length / 2); i++) {    const tmp = s[i];    s[i] = s[s.length - 1 - i];    s[s.length - 1 - i] = tmp;  }}테스트 코드import { describe, expect, test } from \"@jest/globals\";import { reverseString } from \".\";describe(\"Compare Reverse String\", () =&gt; {  test(\"hello\", () =&gt; {    const s: string[] = [\"h\", \"e\", \"l\", \"l\", \"o\"];    reverseString(s);    expect(s).toEqual([\"o\", \"l\", \"l\", \"e\", \"h\"]);  });  test(\"Hannah\", () =&gt; {    const s: string[] = [\"H\", \"a\", \"n\", \"n\", \"a\", \"h\"];    reverseString(s);    expect(s).toEqual([\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]);  });});느낀점해당 문제는 사실 while문에 투 포인터를 활용하라는 문제로 알고 있다.그렇게 했을 때 가독성이 더 좋아보이는 것도 사실이지만, for문을 사용해도 가독성을 크게 해치지는 않는 것 같다.또, typescript로 풀면서 테스트코드를 작성해보고 있는데, jest에서 toBe와 toEqual의 차이가 뭔지 알게 되었다.사실 이렇게 테스트코드를 작성하는 건지는 잘 모르겠다.Github 풀이코드"
  },
  
  {
    "title": "Vaild Palindrome",
    "url": "/posts/valid-palindrome/",
    "categories": "알고리즘",
    "tags": "leetcode",
    "date": "2023-02-10 13:34:00 +0900",
    





    
    "snippet": "125. Vaild Palindrome문제 설명모든 대문자를 소문자로 변환하고, 영어와 숫자가 아닌 문자는 제거한 뒤 앞뒤로 읽어도 똑같은 문장은 팰린드롬이다.문자열 s가 주어질 때, 팰린드롬이면 true를 아니라면 false를 리턴하라.해결 방법  대문자를 소문자로 변환한다.  영어와 숫자가 아닌 문자는 제거한다.  팰린드롬인지 확인한다.풀이 코드e...",
    "content": "125. Vaild Palindrome문제 설명모든 대문자를 소문자로 변환하고, 영어와 숫자가 아닌 문자는 제거한 뒤 앞뒤로 읽어도 똑같은 문장은 팰린드롬이다.문자열 s가 주어질 때, 팰린드롬이면 true를 아니라면 false를 리턴하라.해결 방법  대문자를 소문자로 변환한다.  영어와 숫자가 아닌 문자는 제거한다.  팰린드롬인지 확인한다.풀이 코드export function isPalindrome(s: string): boolean {  const lowerString = s.toLowerCase();  const newString = lowerString.replace(/[^0-9|a-z]/gi, \"\");  for (let i = 0; i &lt; Math.floor(newString.length / 2); i++) {    if (newString[i] !== newString[newString.length - 1 - i]) return false;  }  return true;}먼저, 문자열 전체를 toLowerCase 메서드를 활용해 모두 소문자로 변경한다.그 후 replace와 정규식을 활용해 숫자와 영어가 아닌 모든 문자를 제거한다.마지막으로 팰린드롬 여부를 판단하기 위해 문자열을 순회하며, 양쪽 끝의 문자가 같은지 비교한다.이 때, 중요한 점은 반복문을 끝까지 도는게 아니라 절반만 도는 것이다.테스트 코드import { describe, expect, test } from \"@jest/globals\";import { isPalindrome } from \".\";describe(\"Valid Palindrome\", () =&gt; {  test(\"Palindrome Module\", () =&gt; {    expect(isPalindrome(\"A man, a plan, a canal: Panama\")).toBe(true);    expect(isPalindrome(\"race a car\")).toBe(false);    expect(isPalindrome(\" \")).toBe(true);  });});문제 풀이 코드"
  },
  
  {
    "title": "고전 문제를 통해 알아보는 자바스크립트 원리",
    "url": "/posts/%EA%B3%A0%EC%A0%84-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9B%90%EB%A6%AC/",
    "categories": "Javascript",
    "tags": "Javascript",
    "date": "2022-12-26 22:34:00 +0900",
    





    
    "snippet": "시작하기 전에  “해당 포스팅은 자바스크립트의 원리를 재밌게 알아보기 위해 제가 생각한 설명이 포함되어 틀릴 수 있다는 점 알려드립니다. 나중에 댓글 기능이 생기면 댓글로 알려주셔도 정말 좋겠지만, 지금은 메일로 알려주시면 정말 감사하겠습니다.”시작 지점얼마 전 친구가 자바스크립트 원리에 대해 아냐고 물어본 적이 있다.클로저, 호이스팅을 물어봤는데 저...",
    "content": "시작하기 전에  “해당 포스팅은 자바스크립트의 원리를 재밌게 알아보기 위해 제가 생각한 설명이 포함되어 틀릴 수 있다는 점 알려드립니다. 나중에 댓글 기능이 생기면 댓글로 알려주셔도 정말 좋겠지만, 지금은 메일로 알려주시면 정말 감사하겠습니다.”시작 지점얼마 전 친구가 자바스크립트 원리에 대해 아냐고 물어본 적이 있다.클로저, 호이스팅을 물어봤는데 저는 대답은 안하고 그거는 기본이라고 ‘자바스크립트의 3대 원리인 호이스팅, 클로저, 이벤트 루프가 있다.’라고만 대답했던 적이 있습니다.그 친구는 자바(자바와 자바스크립트는 햄과 햄스터같이 정말 다릅니다!)를 쓰기 때문에 제가 설명 할 자신이 없어서 그랬던 것이기도 한데, 이참에 ‘자바스크립트에 대해 모르는 사람에게도 해당 문제를 쉽게 알려 줄 수 있는 방법이 없을까?’라는 생각에 인터넷을 서칭하던 중 옛날에 보았던 자바스크립트 고전 클로저 문제(?)를 다시 만나게 되었고, 이 문제를 설명하면서 자연스럽게 제가 생각하는 3대 원리를 접목시키는 방식으로 가는 것이 좋겠다는 생각이 들어 이 글을 작성합니다.주의 해야할 점이 게시글은 원리를 정석적으로 깊게 설명하는 것이 아니기 때문에 클로저, 호이스팅, 이벤트 루프의 원리를 수박 겉핥기로만 설명합니다.문제 알아보기먼저, 인터넷에 떠도는 자바스크립트의 망령인 고전 클로저 문제에 대해 한 번 보도록 하겠습니다.function func() {  for (var i = 0; i &lt; 10; i++) {    setTimeout(function () {      console.log(i);    }, 500);  }}func();저는 0.5초 뒤에 0 ~ 9까지 출력하는 함수를 만들고 싶었습니다.그래서 위와 같이 코드를 작성하고 실행했더니 이게 왠걸? 10이 10번 출력되는 것이 아니겠습니까?아니 이게 무슨 일까요? 무슨 문제가 생겨서 이렇게 동작하는 걸까요? 이는 자바스크립트의 원리에 대해 알지 쉽게 해결하지 못할 수도 있습니다.왜 제가 생각했던대로 동작하지 않는지에 대해 먼저 말씀드리자면, 변수(var)의 스코프 문제와 비동기(setTimeout)가 합쳐져 환장의 조합이 탄생했기 때문입니다.var로 선언한 변수의 특성과 비동기를 잠깐 짚고 넘어가자면 var로 선언했을 경우 재할당, 재선언이 가능해지고, 변수의 범위는 함수 스코프를 가지게됩니다.비동기는 말이 어려울 수도 있기 때문에 풀어서 써보자면, “나 다른 일 하고 올테니깐 다음 라인 실행시켜 줘.”라고 할 수 있겠습니다.제가 설명한 것 중에 굵은 글씨를 다시 봐주시기 바랍니다.왜 이러한 현상이 발생했는지 또 이 문제를 어떻게 해결해야하는지는 굵은 글씨에 달려있습니다. 차근차근 가봅시다.함수스코프재선언은 말 그대로 다시 선언 할 수 있다는 것이고, 함수 스코프는 변수를 관리(편의상 관리라고 하겠습니다 너른 양해 부탁드립니다.)하는 곳이 함수가 되는 것입니다.그런데 자바스크립트만 알고 있다면 ‘이게 왜?’라고 생각하실 수 있겠지만 제가 알고있는 언어 중 파이썬을 제외한 거의 대부분의 언어가 재선언이 불가능하고, 블록 스코프를 가지고 있습니다. 이렇기 때문에 우리가 해결하고자 하는 문제는 자바스크립트의 인기가 올라감에 따라 조롱의 대상이 되기도 했습니다.함수스코프를 간단하게 코드로 봐봅시다.function func() {  {    var number = 1;    console.log(number); // 1 출력  }  {    console.log(number); // 1 출력  }  console.log(number); // 1 출력}func();여기서는 설명의 편의상 스코프를 세세하게 나누어보았습니다.한눈에 봐도 뭔가 이상함이 느껴지시나요? 바로 함수 스코프의 원리를 모른다면 이게 어떻게 동작하는지 이해가 안되실 수도 있습니다.앞에서 설명드린대로 var의 경우는 함수에서 변수를 관리하기 때문에 {}이라는 블록 안에 선언을 하더라도 func함수에서 관리를 하게 되는 것입니다.그래서 조금 이상해 보일지 몰라도 동작하게 되는 것이죠.하지만 es2015(es6)부터 let과 const의 등장으로 블록스코프를 지원합니다. let과 const를 사용합시다.비동기비동기는 말씀드렸다시피 “나 대신 이것 좀 실행시켜 줘”입니다.비동기는 깊게 들어가면 책 몇권이 나올정도로 심오한 기술이지만 우리는 초심자의 관점에서 아주 쉽게 알아봅시다.console.log(1);setTimeout(() =&gt; {  console.log(2);}, 100);console.log(3);setTimeout함수 또한 비동기 함수의 일종으로 일정 시간이 지난 후에 전달 받은 함수를 실행해달라는 의미입니다.그럼 위의 코드는 어떻게 출력될 것 같나요? 1, 3, 2순서로 출력이 되겠죠. 정말 쉽죠?그런데 이것만 봐서는 비동기의 원리를 반 쪽만 이해했다고 할 수 있습니다.console.log(1);setTimeout(() =&gt; {  console.log(2);}, 0);console.log(3);그렇다면 위와 같이 setTimeout의 호출 시간이 0인 경우에는 어떻게 실행될까요?출력해보면 1, 3, 2가 똑같이 출력되는 것을 알 수 있습니다.사실 자바스크립트의 비동기는 한 가지 원리가 더 있습니다. 바로 현재 실행이 가능 하더라도 실행 순서가 마지막으로 밀려난다는 것입니다.정확하게 이렇게 동작하는 것은 아니지만,너무 깊게 알면 어렵기 때문에 깊게 알고 싶으신 분들은 실행 컨텍스트와 이벤트 루프에 대해 알아보시기 바랍니다.setTimout 이미지 추가예정문제 해결 과정자 이제 문제 해결을 위한 자바스크립트의 원리는 대충 알아봤습니다.그럼 이 원리를 바탕으로 어떻게 하면 문제를 해결할 수 있을 지 생각해봅시다.다시 코드를 봐보도록 하겠습니다.function func() {  for (var i = 0; i &lt; 10; i++) {    setTimeout(function () {      console.log(i);    }, 500);  }}func();우리는 분명 0 ~ 9를 출력하고 싶었는데 “왜 자바스크립트는 10을 출력했을까?”에 대한 답을 앞서 배운 2 가지의 특성을 통해 한 번 알아봅시다.앞서 비동기를 사용하는 함수는 호출하게 되면 순위가 뒤로 밀린다고 했죠?그렇기 때문에 setTimeout에 의해 호출 된 함수 즉, i를 출력하는 함수는 후 순위로 밀려나게 됩니다.또한 i는 var로 선언된 변수이기 때문에 함수 스코프를 가집니다.반복문을 풀어서 보면 더 쉽기 때문에 한 번 풀어봅시다.(편의를 위해 풀어쓴 것이지 실제로는 이렇게 동작하지 않습니다.)반복문의 정확한 동작과정을 알고 싶으시면 반복문 동작 과정을 찾아보시기 바랍니다.function func() {  var i = 0;  if (i &lt; 10) {    // 길이를 위해 화살표 함수로 변경 한 점 양해 바랍니다.    setTimeout(() =&gt; console.log(i), 500);  }  if (i &lt; 10) {    var i = ++i;    setTimeout(() =&gt; console.log(i), 500);  }  ...}  이 코드를 작성하던 도중 한 가지 흥미로운 사실을 발견했습니다.비동기 코드를 작성할 때(8번 째 줄) 전위 연산자와 후위 연산자에 따라 비동기 요청 값이 바뀌는 것을 확인했습니다.해당 사항은 조금 찾아봐야겠지만 이 포스팅과는 크게 연관이 없기 때문에 궁금하신 분들은 찾아보시는 것도 재밌을 것 같습니다.위의 코드를 실행하게 되면, console.log는 후 순위로 밀려나게 되고, i를 먼저 더합니다.더한 뒤 또 setTimout을 만나 console.log는 후 순위로 밀려나가는 과정이 10번 반복됩니다.이렇게 console.log는 10번 후 순위로 밀려나게 되고, 그 동안 i의 값은 10이 되어 10이 10번 출력되는 것입니다.대충 비동기 이미지 추가 예정문제 해결이러한 원리를 알았다면, 이제 내가 원하는대로 0 ~ 9까지 출력할 수도 있겠죠?첫 번째 방법첫 번째 방법은 즉시실행함수(IIFE)를 이용하는 것이다.IIFE를 이용하게 되면, 값을 함수에 전달함으로써 값을 기억하고 있게 만들 수 있다.대충 스코프 이미지 추가 예정function func() {  for (var i = 0; i &lt; 10; i++) {    (function (i) {      setTimeout(() =&gt; console.log(i), 500);    })(i);  }}func();두 번째 방법두 번째 방법으로는 let을 사용하여 블록 스코프를 사용하는 것입니다.var는 함수 스코프이기 때문에 생성된 비동기 함수가 전체적으로 영향을 받았다면,let을 사용함으로써 블록 스코프로 만들어 내가 원하는 비동기 함수만 영향이 가게 만들 수 있습니다.function func() {  for (let i = 0; i &lt; 10; i++) {    setTimeout(() =&gt; console.log(i), 500);  }}func();마무리이렇게 고전 클로저 문제를 해결했습니다. 자바스크립트와 한 발자국 더 가까워진 것 같네요.그런데 함수 스코프를 블록 스코프로 잘 조작하는 것만으로도 해결이 가능했습니다.그렇기 때문에 제 짧은 지식으로는 해당 문제가 왜 클로저 문제인지 정확하게 모르겠습니다.찾아보지 않았기 때문에 몇 가지 추측을 해볼 수 있을 것 같은데요.  클로저는 내가 호출된 시점에 스코프를 기억하는 것이다.그렇기 때문에 당연히 for문을 돌 때마다 기억하고 있을 줄 알았던 i를 기억하지 못했다(원리에 대한 이해 미숙).  해당 문제는 let이 나오기 이전에 발생했던 고전 문제로 알고있다(최소 10년).그렇기 때문에 당연히 IIFE를 통해 해결할 수 밖에 없었고, 이는 스코프를 한 단계 더 생성한 클로저 환경을 만들었기 때문에 클로저 문제라고 할 수 있다(해당 문제는 더 이상 IIFE로 해결하지 않음).제 개인적인 의견으로는 이제는 충분히 블록 스코프로 만들어 해결이 가능하기 때문에 더 이상 해당 문제는 클로저 문제라고 보기는 어려워 보입니다."
  }
  
]

